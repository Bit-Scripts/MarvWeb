#!/usr/bin/env node

const http = require('http');
const crypto = require('crypto');
const {
  Server
} = require('socket.io');

const {
  Marv
} = require('../marv');

const app = require('../app');
const {
  db
} = require('../db');

function hashIP(ip) {
  return crypto
    .createHmac('sha256', process.env.IP_SALT || 'change-me')
    .update(ip || '')
    .digest('hex');
}

function getRealIpFromSocket(socket) {
  return (
    socket.handshake.headers['cf-connecting-ip'] ||
    (socket.handshake.headers['x-forwarded-for'] ?
      String(socket.handshake.headers['x-forwarded-for']).split(',')[0].trim() :
      '') ||
    socket.request?.socket?.remoteAddress ||
    ''
  );
}

var port = normalizePort(process.env.PORT || '3017');
app.set('port', port);

var server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: ['https://marv-bot.fr', 'http://marv-bot.fr', 'http://localhost:3017'],
    methods: ['GET', 'POST'],
    credentials: true
  },
  transports: ['websocket', 'polling']
});

io.use((socket, next) => {
  const token = socket.handshake.auth?.token;
  if (!token) {
    return next(new Error("NO_TOKEN"));
  }
  next();
});

io.on('connection', (socket) => {
  const token = socket.handshake.auth?.token;

  console.log('✅ socket connected', socket.id, 'auth.token=', token?.slice(0, 8));

  // token doit etre un hex long (32+), sinon c'est ton bug de token tronque
  if (!token || token.length < 32) {
    socket.emit('marv', 'Erreur: Session invalide. Recharge la page.');
    socket.disconnect(true);
    return;
  }

  // cree l'utilisateur a la connexion (1 fois)
  db.run(`INSERT OR IGNORE INTO users (token, hashed_ip) VALUES (?, ?)`, [token, null]);

  socket.on('marv', async (data, cb) => {
    const realIP = getRealIpFromSocket(socket);
    const hashedIP = hashIP(realIP);

    if (!token) {
      cb?.({ ok: false, error: 'NO_TOKEN' });
      return;
    }

    db.get(`SELECT token FROM users WHERE token = ?`, [token], async (err, user) => {
      if (err || !user) {
        cb?.({ ok: false, error: 'INVALID_SESSION' });
        return;
      }

      db.run(
        `INSERT INTO conversations (token, message, latitude, longitude, timezone, hashed_ip)
        VALUES (?, ?, ?, ?, ?, ?)`,
        [token, data.message, data.latitude, data.longitude, data.tz, hashedIP],
        async function (err2) {
          if (err2) {
            cb?.({ ok: false, error: 'DB_INSERT_FAILED' });
            return;
          }

          const userMsgId = this.lastID; // <= VOILA ton id

          // ACK tout de suite (comme ca pas de timeout meme si l'IA prend du temps)
          cb?.({ ok: true, id: userMsgId });

          try {
            const reply = await Marv(
              data.message,
              data.tz,
              data.message,
              data.latitude,
              data.longitude
            );

            db.run(
              `INSERT INTO conversations (token, message, latitude, longitude, timezone, hashed_ip)
              VALUES (?, ?, ?, ?, ?, ?)`,
              [token, reply, data.latitude, data.longitude, data.tz, hashedIP]
            );

            socket.emit('marv', reply);

          } catch (e) {
            console.error('❌ Marv error', e);
            socket.emit('marv', "Désolé, j'ai eu un souci avec l'IA.");
          }
        }
      );
    });
  });
  socket.on('disconnect', (reason) => {
    console.log('❌ socket disconnected', socket.id, reason);
  });
});

server.listen(port, '0.0.0.0', () => {
  console.log('Listening on port', port);
});

function normalizePort(val) {
  var port = parseInt(val, 10);
  if (isNaN(port)) return val;
  if (port >= 0) return port;
  return false;
}