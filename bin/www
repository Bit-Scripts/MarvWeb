#!/usr/bin/env node
const http = require('http');
const crypto = require('crypto');
const { Server } = require('socket.io');

const { Marv } = require('../marv');

const app = require('../app');
const { db } = require('../db');

function hashIP(ip) {
  return crypto
    .createHmac('sha256', process.env.IP_SALT || 'change-me')
    .update(ip || '')
    .digest('hex');
}

function getRealIpFromSocket(socket) {
  return (
    socket.handshake.headers['cf-connecting-ip'] ||
    (socket.handshake.headers['x-forwarded-for']
      ? String(socket.handshake.headers['x-forwarded-for']).split(',')[0].trim()
      : '') ||
    socket.request?.socket?.remoteAddress ||
    ''
  );
}

var port = normalizePort(process.env.PORT || '3017');
app.set('port', port);

var server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: ['https://marv-bot.fr', 'http://marv-bot.fr', 'http://localhost:3017'],
    methods: ['GET', 'POST'],
    credentials: true
  },
  transports: ['websocket', 'polling']
});

io.use((socket, next) => {
  const token = socket.handshake.auth?.token;
  if (!token) {
    return next(new Error("NO_TOKEN"));
  }
  next();
});

io.on('connection', (socket) => {
  const token = socket.handshake.auth?.token;

  console.log('✅ socket connected', socket.id, 'auth.token=', token?.slice(0, 8));

  // token doit etre un hex long (32+), sinon c'est ton bug de token tronque
  if (!token || token.length < 32) {
    socket.emit('marv', 'Erreur: Session invalide. Recharge la page.');
    socket.disconnect(true);
    return;
  }

  // cree l'utilisateur a la connexion (1 fois)
  db.run(`INSERT OR IGNORE INTO users (token, hashed_ip) VALUES (?, ?)`, [token, null]);

  socket.on('marv', (data) => {
    const realIP = getRealIpFromSocket(socket);
    const hashedIP = hashIP(realIP);

    db.get(`SELECT token FROM users WHERE token = ?`, [token], (err, user) => {
      if (err) {
        console.error('❌ DB', err);
        socket.emit('marv', 'Erreur serveur.');
        return;
      }

      // si jamais course SQLite, on re-insert puis on continue
      if (!user) {
        db.run(`INSERT OR IGNORE INTO users (token, hashed_ip) VALUES (?, ?)`, [token, null], () => {
          // continue quand meme
          db.run(
            `INSERT INTO conversations (token, message, latitude, longitude, timezone, hashed_ip)
             VALUES (?, ?, ?, ?, ?, ?)`,
            [token, data.message, data.latitude, data.longitude, data.tz, hashedIP],
            function (err2) {
              if (err2) {
                console.error('❌ insert conv', err2);
                socket.emit('marv', 'Erreur sauvegarde.');
                return;
              }
              socket.emit('marv', `ok (id=${this.lastID})`);
            }
          );
        });
        return;
      }

      db.run(
        `INSERT INTO conversations (token, message, latitude, longitude, timezone, hashed_ip)
         VALUES (?, ?, ?, ?, ?, ?)`,
        [token, data.message, data.latitude, data.longitude, data.tz, hashedIP],
        function (err2) {
          if (err2) {
            console.error('❌ insert conv', err2);
            socket.emit('marv', 'Erreur sauvegarde.');
            return;
          }
          socket.emit('marv', `ok (id=${this.lastID})`);
        }
      );
    });
  });

  socket.on('disconnect', (reason) => {
    console.log('❌ socket disconnected', socket.id, reason);
  });
});

server.listen(port, '0.0.0.0', () => {
  console.log('Listening on port', port);
});

function normalizePort(val) {
  var port = parseInt(val, 10);
  if (isNaN(port)) return val;
  if (port >= 0) return port;
  return false;
}
