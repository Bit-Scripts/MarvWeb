#!/usr/bin/env node
const http = require('http');
const crypto = require('crypto');
const { Server } = require('socket.io');

const { Marv } = require('../marv');

const app = require('../app');
const { db } = require('../db');

var port = normalizePort(process.env.PORT || '3017');
app.set('port', port);

var server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: ['https://marv-bot.fr', 'http://marv-bot.fr', 'http://localhost:3017'],
    methods: ['GET', 'POST'],
    credentials: true
  },
  transports: ['websocket', 'polling']
});

io.use((socket, next) => {
  const token = socket.handshake.auth?.token;
  if (!token) {
    return next(new Error("NO_TOKEN"));
  }
  next();
});

io.on('connection', (socket) => {
  const token = socket.handshake.auth?.token;

  console.log('✅ socket connected', socket.id, 'auth.token=', token?.slice(0, 8));

  // token doit etre un hex long (32+), sinon c'est ton bug de token tronque
  if (!token || token.length < 32) {
    socket.emit('marv', 'Erreur: Session invalide. Recharge la page.');
    socket.disconnect(true);
    return;
  }

  // cree l'utilisateur a la connexion (1 fois)
  db.run(`INSERT OR IGNORE INTO users (token, hashed_ip) VALUES (?, ?)`, [token, null]);

  socket.on('marv', async (data) => {
    const realIP =
      socket.handshake.headers['cf-connecting-ip'] ||
      (socket.handshake.headers['x-forwarded-for']
        ? String(socket.handshake.headers['x-forwarded-for']).split(',')[0].trim()
        : '') ||
      socket.request?.socket?.remoteAddress ||
      '';

    const hashedIP = crypto
      .createHmac('sha256', process.env.IP_SALT || 'change-me')
      .update(realIP)
      .digest('hex');

    if (!token) {
      socket.emit('marv', 'Erreur: Session invalide. Recharge la page.');
      return;
    }

    db.get(`SELECT token FROM users WHERE token = ?`, [token], async (err, user) => {
      if (err) {
        console.error('❌ DB', err);
        socket.emit('marv', 'Erreur serveur.');
        return;
      }

      if (!user) {
        socket.emit('marv', 'Erreur: Session invalide. Recharge la page.');
        return;
      }

      // 1️⃣ Sauvegarde la question utilisateur
      db.run(
        `INSERT INTO conversations (token, message, latitude, longitude, timezone, hashed_ip)
        VALUES (?, ?, ?, ?, ?, ?)`,
        [token, data.message, data.latitude, data.longitude, data.tz, hashedIP],
        async function (err2) {
          if (err2) {
            console.error('❌ insert conv', err2);
            socket.emit('marv', 'Erreur sauvegarde.');
            return;
          }

          try {
            // 2️⃣ Appel IA
            const reply = await Marv(
              data.message,          // question
              data.tz,               // timezone
              data.message,          // messageClient (oui, pareil ici)
              data.latitude,
              data.longitude
            );

            // 3️⃣ Sauvegarde la reponse IA (optionnel mais conseille)
            db.run(
              `INSERT INTO conversations (token, message, latitude, longitude, timezone, hashed_ip)
              VALUES (?, ?, ?, ?, ?, ?)`,
              [token, reply, data.latitude, data.longitude, data.tz, hashedIP]
            );

            // 4️⃣ Envoie la reponse au client
            socket.emit('marv', reply);

          } catch (e) {
            console.error('❌ Marv error', e);
            socket.emit('marv', "Désolé, j'ai eu un souci avec l'IA.");
          }
        }
      );
    });
  });

  socket.on('disconnect', (reason) => {
    console.log('❌ socket disconnected', socket.id, reason);
  });
});

server.listen(port, '0.0.0.0', () => {
  console.log('Listening on port', port);
});

function normalizePort(val) {
  var port = parseInt(val, 10);
  if (isNaN(port)) return val;
  if (port >= 0) return port;
  return false;
}
